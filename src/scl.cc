#include <charconv>
#include <lexible.hh>
#include <optional>
#include <stdexcept>
#include <string>
#include <utility>

#include "scl.hh"

/* generated by c++gen */

enum class TokenType
{
  LEXIBLE_EOF,

  WhitespaceSkip,

  TableDecl,
  TableArrayDecl,

  Key,
  Number,
  String,
  Equals,

  ListStart,
  ListEnd,

  TrueLiteral,
  FalseLiteral,
};

constexpr std::string_view
token_name(TokenType t)
{

  switch (t) {
    case TokenType::WhitespaceSkip:
      return "WhitespaceSkip";
    case TokenType::TableDecl:
      return "TableDecl";
    case TokenType::TableArrayDecl:
      return "TableArrayDecl";
    case TokenType::Key:
      return "Key";
    case TokenType::Number:
      return "Number";
    case TokenType::String:
      return "String";
    case TokenType::Equals:
      return "Equals";
    case TokenType::ListStart:
      return "ListStart";
    case TokenType::ListEnd:
      return "ListEnd";
    case TokenType::TrueLiteral:
      return "TrueLiteral";
    case TokenType::FalseLiteral:
      return "FalseLiteral";
    case TokenType::LEXIBLE_EOF:
      return "EOF";
  }
  std::unreachable();
}

namespace morphemes {
using namespace std::string_view_literals;

constexpr auto skip_morpheme_regex = "(\\s+)|(#.*\\n)"sv;

constexpr auto table_decl_regex = "\\[([a-zA-Z_]+)(\\.[a-zA-Z_]+)*\\]"sv;
constexpr auto table_array_decl_regex =
  "\\[\\[([a-zA-Z_]+)(\\.[a-zA-Z_]+)*\\]\\]"sv;

constexpr auto key_morpheme_regex = "[a-zA-Z_]+"sv;
constexpr auto number_morpheme_regex = "[0-9]+(\\.[0-9]+)?"sv;
constexpr auto string_morpheme_regex = "\".*\""sv;
constexpr auto equals_morpheme_regex = "="sv;
constexpr auto list_start_morpheme_regex = "\\{"sv;
constexpr auto list_end_morpheme_regex = "\\}"sv;
constexpr auto true_morpheme_regex = "true"sv;
constexpr auto false_morpheme_regex = "false"sv;

using skip_morpheme =
  lexible::morpheme<skip_morpheme_regex, TokenType::WhitespaceSkip, 1000>;

using table_array_decl_morpheme =
  lexible::morpheme<table_array_decl_regex, TokenType::TableArrayDecl, 2>;

using table_decl_morpheme =
  lexible::morpheme<table_decl_regex, TokenType::TableDecl, 1>;

using key_morpheme = lexible::morpheme<key_morpheme_regex, TokenType::Key, 0>;

using number_morpheme =
  lexible::morpheme<number_morpheme_regex, TokenType::Number, 0>;

using string_morpheme =
  lexible::morpheme<string_morpheme_regex, TokenType::String, 0>;

using equals_morpheme =
  lexible::morpheme<equals_morpheme_regex, TokenType::Equals, 0>;

using list_start_morpheme =
  lexible::morpheme<list_start_morpheme_regex, TokenType::ListStart, 0>;
using list_end_morpheme =
  lexible::morpheme<list_end_morpheme_regex, TokenType::ListEnd, 0>;

using true_morpheme =
  lexible::morpheme<true_morpheme_regex, TokenType::TrueLiteral, 1, true>;
using false_morpheme =
  lexible::morpheme<false_morpheme_regex, TokenType::FalseLiteral, 1, true>;

};

using lexer = lexible::lexer<TokenType,
                             morphemes::skip_morpheme,
                             morphemes::table_array_decl_morpheme,
                             morphemes::table_decl_morpheme,
                             morphemes::key_morpheme,
                             morphemes::number_morpheme,
                             morphemes::string_morpheme,
                             morphemes::equals_morpheme,
                             morphemes::list_start_morpheme,
                             morphemes::list_end_morpheme
                             // morphemes::true_morpheme,
                             // morphemes::false_morpheme
                             >;

struct State
{
  std::map<std::string, scl::table, std::less<>> m_tables;
  std::map<std::string, scl::table_array, std::less<>> m_tableArrays;
};

using pctx = lexible::ParsingContext<lexer, State>;

struct value_parse;

// failable function
struct array_parse
  : pctx::AndThen<pctx::MorphemeParser<TokenType::ListStart>,
                  pctx::Repeat<value_parse, false>,
                  pctx::MorphemeParser<TokenType::ListEnd>>
{
  static constexpr size_t CUT_AT = 1;
  constexpr static std::string_view CUT_ERROR = "when trying to parse an array";

  scl::value operator()(State&, auto tup)
  {
    auto [_0, list, _2] = tup;
    return scl::value(scl::array(std::move(list)));
  }
};

struct value_parse
  : pctx::Any<pctx::MorphemeParser<TokenType::Number>,
              pctx::MorphemeParser<TokenType::String>,
              array_parse,
              pctx::MorphemeParser<TokenType::TrueLiteral>,
              pctx::MorphemeParser<TokenType::FalseLiteral>>
{
  // number parser
  scl::value operator()(State&, std::string_view in, pctx::placeholder_t<0>)
  {
    double d;
    std::from_chars(in.begin(), in.end(), d);
    return scl::value(d);
  }

  // string parser
  scl::value operator()(State&, std::string_view in, pctx::placeholder_t<1>)
  {
    std::string s;
    s = in.substr(1, in.size() - 2);
    return scl::value(s);
  }

  scl::value operator()(State&, scl::value in, pctx::placeholder_t<2>)
  {
    return in;
  }

  scl::value operator()(State&, std::string_view, pctx::placeholder_t<3>)
  {
    return scl::value(true);
  }

  scl::value operator()(State&, std::string_view, pctx::placeholder_t<4>)
  {
    return scl::value(false);
  }

  std::string err(State&)
  {
    printf("erroring\n");
    return "hmm";
  }
};

using key_value = std::pair<std::string, scl::value>;

struct key_value_parse
  : pctx::AndThen<
      pctx::MorphemeParser<TokenType::Key,
                           "expected key at start of key-value pair">,
      pctx::MorphemeParser<
        TokenType::Equals,
        "expected equals after identifier in key-value pair">,
      value_parse>
{
  // cut after starting to parse
  constexpr static size_t CUT_AT = 1;
  constexpr static std::string_view CUT_ERROR = "when parsing key-value pair";

  key_value operator()(State&, auto tup)
  {
    auto const [name, _0, value] = tup;

    return { std::string(name), value };
  }
};

using table_parse_inner = pctx::Repeat<key_value_parse, false>;
using table_pair = std::pair<std::string, scl::table>;
using table_array_pair = std::pair<std::string, scl::table_array>;

struct table_parse
  : pctx::AndThen<pctx::MorphemeParser<TokenType::TableDecl>, table_parse_inner>
{
  // don't cut, never going to throw a cut error
  constexpr static size_t CUT_AT = 999;
  constexpr static std::string_view CUT_ERROR = "";

  std::pair<std::string, scl::table> operator()(State&, auto in)
  {
    auto const& [table_name, values] = in;

    scl::table table;

    for (auto const& v : values)
      table.insert_or_assign(v.first, std::move(v.second));

    // trim the table names brackets
    auto table_name_trimmed = table_name.substr(1, table_name.size() - 2);
    return { std::string(table_name_trimmed), table };
  }
};

struct table_array_parse
  : pctx::AndThen<pctx::MorphemeParser<TokenType::TableArrayDecl>,
                  table_parse_inner>
{
  // don't cut, never going to throw a cut error
  constexpr static size_t CUT_AT = 999;
  constexpr static std::string_view CUT_ERROR = "";

  std::pair<std::string, scl::table> operator()(State&, auto in)
  {
    auto const& [table_name, values] = in;

    scl::table table;

    for (auto const& v : values)
      table.insert_or_assign(v.first, std::move(v.second));

    // trim the table names brackets
    auto table_name_trimmed = table_name.substr(2, table_name.size() - 4);
    return { std::string(table_name_trimmed), table };
  }
};

struct toplevel_parse : pctx::Any<table_parse, table_array_parse>
{
  // TODO: convert these to rvalues?
  lexible::empty_t operator()(State& s, table_pair tbl, pctx::placeholder_t<0>)
  {
    if (s.m_tables.contains(tbl.first))
      throw std::runtime_error(
        "attempting to create two distinct tables of the exact same name.");

    if (s.m_tableArrays.contains(tbl.first))
      throw std::runtime_error("attempting to create a distinct table while a "
                               "table array also exists with the same name.");

    s.m_tables.insert({ std::string(tbl.first), std::move(tbl.second) });

    return {};
  }

  lexible::empty_t operator()(State& s, table_pair tbl, pctx::placeholder_t<1>)
  {
    if (s.m_tables.contains(tbl.first))
      throw std::runtime_error(
        "attempting to create two distinct tables of the exact same name.");

    // create the table array first
    if (not s.m_tableArrays.contains(tbl.first))
      s.m_tableArrays.insert_or_assign(std::string(tbl.first),
                                       scl::table_array{});

    s.m_tableArrays[tbl.first].push_back(tbl.second);

    return {};
  }
};

// expect a full parse with EOF at the end
using parser =
  pctx::Engine<pctx::ExpectEOF<pctx::Repeat<toplevel_parse, false>>>;

namespace scl {

scl_file::scl_file(std::string_view in)
{
  State s;
  auto out = parser(in).parse(s);

  if (not out)
    throw std::runtime_error(
      std::format("failed to parse scl file, err:\n{}\n", out.error().what()));

  m_tables = std::move(s.m_tables);
  m_tableArrays = std::move(s.m_tableArrays);
};

};
