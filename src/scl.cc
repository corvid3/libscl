#include <charconv>
#include <lexible.hh>
#include <string>

#include "scl.hh"

/* generated by c++gen */

enum class TokenType
{
  WhitespaceSkip,

  TableDecl,
  TableArrayDecl,

  Key,
  Number,
  String,
  Equals,

  ListStart,
  ListEnd,
};

namespace morphemes {
using namespace std::string_view_literals;

constexpr auto skip_morpheme_regex = "\\s+"sv;

constexpr auto table_decl_regex = "\\[([a-zA-Z_]+)(\\.[a-zA-Z_]+)*\\]"sv;
constexpr auto table_array_decl_regex =
  "\\[\\[([a-zA-Z_]+)(\\.[a-zA-Z_]+)*\\]\\]"sv;

constexpr auto key_morpheme_regex = "[a-zA-Z_]+"sv;
constexpr auto number_morpheme_regex = "[0-9]+(\\.[0-9]+)?"sv;
constexpr auto string_morpheme_regex = "\".*\""sv;
constexpr auto equals_morpheme_regex = "="sv;
constexpr auto list_start_morpheme_regex = "\\{"sv;
constexpr auto list_end_morpheme_regex = "\\}"sv;

using skip_morpheme =
  lexible::morpheme<skip_morpheme_regex, TokenType::WhitespaceSkip, 1000>;

using table_array_decl_morpheme =
  lexible::morpheme<table_array_decl_regex, TokenType::TableArrayDecl, 2>;

using table_decl_morpheme =
  lexible::morpheme<table_decl_regex, TokenType::TableDecl, 1>;

using key_morpheme = lexible::morpheme<key_morpheme_regex, TokenType::Key, 0>;

using number_morpheme =
  lexible::morpheme<number_morpheme_regex, TokenType::Number, 0>;

using string_morpheme =
  lexible::morpheme<string_morpheme_regex, TokenType::String, 0>;

using equals_morpheme =
  lexible::morpheme<equals_morpheme_regex, TokenType::Equals, 0>;

using list_start_morpheme =
  lexible::morpheme<list_start_morpheme_regex, TokenType::ListStart, 0>;
using list_end_morpheme =
  lexible::morpheme<list_end_morpheme_regex, TokenType::ListEnd, 0>;

};

using lexer = lexible::lexer<TokenType,
                             morphemes::skip_morpheme,
                             morphemes::table_array_decl_morpheme,
                             morphemes::table_decl_morpheme,
                             morphemes::key_morpheme,
                             morphemes::number_morpheme,
                             morphemes::string_morpheme,
                             morphemes::equals_morpheme,
                             morphemes::list_start_morpheme,
                             morphemes::list_end_morpheme>;

struct State
{
  std::map<std::string, scl::table, std::less<>> m_tables;
  std::map<std::string, scl::table_array, std::less<>> m_tableArrays;
};

using pctx = lexible::ParsingContext<lexer, State>;

struct value_parse;

struct array_parse
  : pctx::AndThen<pctx::MorphemeParser<TokenType::ListStart>,
                  pctx::Repeat<value_parse, false>,
                  pctx::MorphemeParser<TokenType::ListEnd>>
{
  scl::value operator()(State&, auto tup) const
  {
    auto [_0, list, _2] = tup;
    return (list);
  }
};

struct value_parse
  : pctx::Any<pctx::MorphemeParser<TokenType::Number>,
              pctx::MorphemeParser<TokenType::String>,
              array_parse>
{
  // number parser
  scl::value operator()(State&,
                        std::string_view in,
                        pctx::placeholder_t<0>) const
  {
    double d;
    std::from_chars(in.begin(), in.end(), d);
    return scl::value(d);
  }

  // string parser
  scl::value operator()(State&,
                        std::string_view in,
                        pctx::placeholder_t<1>) const
  {
    std::string s;
    s = in.substr(1, in.size() - 2);
    return scl::value(s);
  }

  scl::value operator()(State&, scl::value in, pctx::placeholder_t<2>) const
  {
    return in;
  }
};

using key_value = std::pair<std::string, scl::value>;

struct key_value_parse
  : pctx::AndThen<pctx::MorphemeParser<TokenType::Key>,
                  pctx::MorphemeParser<TokenType::Equals>,
                  value_parse>
{
  key_value operator()(State&, auto tup) const
  {
    auto const [name, _0, value] = tup;

    return { std::string(name), value };
  }
};

using table_parse_inner = pctx::Repeat<key_value_parse, false>;
using table_pair = std::pair<std::string, scl::table>;
using table_array_pair = std::pair<std::string, scl::table_array>;

struct table_parse
  : pctx::AndThen<pctx::MorphemeParser<TokenType::TableDecl>, table_parse_inner>
{
  std::pair<std::string, scl::table> operator()(State&, auto in) const
  {
    auto [table_name, values] = in;

    scl::table table;

    for (auto const& v : values)
      table[v.first] = std::move(v.second);

    // trim the table names brackets
    auto table_name_trimmed = table_name.substr(1, table_name.size() - 2);
    return { std::string(table_name_trimmed), table };
  }
};

struct table_array_parse
  : pctx::AndThen<pctx::MorphemeParser<TokenType::TableArrayDecl>,
                  table_parse_inner>
{
  std::pair<std::string, scl::table> operator()(State&, auto in) const
  {
    auto [table_name, values] = in;

    scl::table table;

    for (auto const& v : values)
      table[v.first] = std::move(v.second);

    // trim the table names brackets
    auto table_name_trimmed = table_name.substr(2, table_name.size() - 3);
    return { std::string(table_name_trimmed), table };
  }
};

struct toplevel_parse : pctx::Any<table_parse, table_array_parse>
{
  // TODO: convert these to rvalues?
  pctx::empty_t operator()(State& s,
                           table_pair tbl,
                           pctx::placeholder_t<0>) const
  {
    if (s.m_tables.contains(tbl.first))
      throw std::runtime_error(
        "attempting to create two distinct tables of the exact same name.");

    if (s.m_tableArrays.contains(tbl.first))
      throw std::runtime_error("attempting to create a distinct table while a "
                               "table array also exists with the same name.");

    s.m_tables.insert({ std::string(tbl.first), std::move(tbl.second) });

    return {};
  }

  pctx::empty_t operator()(State& s,
                           table_pair tbl,
                           pctx::placeholder_t<1>) const
  {
    if (s.m_tables.contains(tbl.first))
      throw std::runtime_error(
        "attempting to create two distinct tables of the exact same name.");

    // create the table array first
    if (not s.m_tableArrays.contains(tbl.first))
      s.m_tableArrays.insert_or_assign(std::string(tbl.first),
                                       scl::table_array{});

    s.m_tableArrays[tbl.first].push_back(tbl.second);

    return {};
  }
};

using parser = pctx::Parser<pctx::Repeat<toplevel_parse, false>>;

namespace scl {

scl_file::scl_file(std::string_view in)
{
  State s;
  auto out = parser(in).parse(s);

  if (not out)
    throw std::runtime_error("failed to parse scl file");

  m_tables = std::move(s.m_tables);
  m_tableArrays = std::move(s.m_tableArrays);
};

};
