#pragma once

/* generated by c++gen */

#include <concepts>
#include <exception>
#include <format>
#include <list>
#include <map>
#include <string>
#include <string_view>
#include <variant>
#include <vector>

namespace scl {

class value;

using string = std::string;
using number = double;
using array = std::vector<value>;

using table = std::map<std::string, value>;
using table_array = std::list<table>;

class value
{
public:
  // TODO: uhhh get rid of this
  constexpr value() = default;

  constexpr value(std::string_view const& str)
    : m_value(std::string(str)) {};
  constexpr value(std::convertible_to<double> auto const num)
    : m_value(num) {};
  constexpr value(array&& a)
    : m_value(a) {};

  value(value const& rhs)
    : m_value(rhs.m_value) {};

  value& operator=(value const& rhs)
  {
    m_value = rhs.m_value;
    return *this;
  }

  template<typename T, typename EXCEPTION_TYPE = std::runtime_error>
  auto const& get(auto const to_throw) const
  {
    if (std::holds_alternative<T>(m_value))
      return std::get<T>(m_value);
    else
      throw EXCEPTION_TYPE(to_throw);
  }

  template<typename T, typename EXCEPTION_TYPE = std::runtime_error>
  auto& get(auto const to_throw)
  {
    if (std::holds_alternative<T>(m_value))
      return std::get<T>(m_value);
    else
      throw EXCEPTION_TYPE(to_throw);
  }

  void emplace(auto&& in) { m_value = in; }

private:
  std::variant<string, number, array> m_value;
};

class scl_search_exception : public std::exception
{
public:
  scl_search_exception(std::string_view name)
    : name(name)
  {
    m_what = std::format("searching for {}, couldn't find it", name);
  }

  // what name one is looking for
  std::string_view const name;

  char const* what() const noexcept override { return m_what.c_str(); }

private:
  std::string m_what;
};

class scl_file
{
public:
  friend struct State;

  // parses a scl_file
  scl_file(std::string_view);

  bool table_exists(std::string_view name) const
  {
    return not(m_tables.find(name) == m_tables.end());
  }

  bool array_table_exists(std::string_view name) const
  {
    return not(m_tables.find(name) == m_tables.end());
  }

  auto& get_table(std::string_view name)
  {
    auto out = m_tables.find(name);
    if (out == m_tables.end())
      throw scl_search_exception(name);
    return out->second;
  }

  auto& get_table_array(std::string_view name)
  {
    auto out = m_tableArrays.find(name);
    if (out == m_tableArrays.end())
      throw scl_search_exception(name);
    return out->second;
  }

  auto num_tables() const { return m_tables.size(); }

  void insert_table(std::string_view name, table&& t) &
  {
    m_tables.insert_or_assign(std::string(name), t);
  }

  void insert_table_array(std::string_view name, table_array&& ta) &
  {
    m_tableArrays.insert_or_assign(std::string(name), ta);
  }

  // TODO:
  // std::string serialize() const;

private:
  scl_file() = default;

  std::map<std::string, table, std::less<>> m_tables;
  std::map<std::string, table_array, std::less<>> m_tableArrays;
};

};
