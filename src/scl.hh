#pragma once

/* generated by c++gen */

#include <concepts>
#include <exception>
#include <format>
#include <list>
#include <map>
#include <string>
#include <string_view>
#include <type_traits>
#include <variant>
#include <vector>

namespace scl {

class value;

using string = std::string;
using number = double;
using array = std::vector<value>;

using table = std::map<std::string, value, std::less<>>;
using table_array = std::list<table>;

class value
{
public:
  // TODO: uhhh get rid of this
  constexpr value() = default;

  constexpr value(std::string_view const& str)
    : m_value(std::string(str)) {};
  constexpr value(std::convertible_to<double> auto const num)
    : m_value(num) {};
  constexpr value(array&& a)
    : m_value(a) {};

  value(value const& rhs)
    : m_value(rhs.m_value) {};

  value& operator=(value const& rhs)
  {
    m_value = rhs.m_value;
    return *this;
  }

  template<typename T, typename EXCEPTION_TYPE = std::runtime_error>
  auto const& get(auto const to_throw) const
  {
    if (std::holds_alternative<T>(m_value))
      return std::get<T>(m_value);
    else
      throw EXCEPTION_TYPE(to_throw);
  }

  template<typename T, typename EXCEPTION_TYPE = std::runtime_error>
  auto& get(auto const to_throw)
  {
    if (std::holds_alternative<T>(m_value))
      return std::get<T>(m_value);
    else
      throw EXCEPTION_TYPE(to_throw);
  }

  void emplace(auto&& in) { m_value = in; }

private:
  std::variant<string, number, array> m_value;
};

class scl_search_exception : public std::exception
{
public:
  scl_search_exception(std::string_view name)
    : name(name)
  {
    m_what = std::format("searching for {}, couldn't find it", name);
  }

  // what name one is looking for
  std::string_view const name;

  char const* what() const noexcept override { return m_what.c_str(); }

private:
  std::string m_what;
};

class scl_file
{
public:
  friend struct State;

  // parses a scl_file
  scl_file(std::string_view);

  bool table_exists(std::string_view name) const
  {
    return not(m_tables.find(name) == m_tables.end());
  }

  bool array_table_exists(std::string_view name) const
  {
    return not(m_tables.find(name) == m_tables.end());
  }

  auto& get_table(std::string_view name)
  {
    auto out = m_tables.find(name);
    if (out == m_tables.end())
      throw scl_search_exception(name);
    return out->second;
  }

  auto& get_table_array(std::string_view name)
  {
    auto out = m_tableArrays.find(name);
    if (out == m_tableArrays.end())
      throw scl_search_exception(name);
    return out->second;
  }

  auto num_tables() const { return m_tables.size(); }

  void insert_table(std::string_view name, table&& t) &
  {
    m_tables.insert_or_assign(std::string(name), t);
  }

  void insert_table_array(std::string_view name, table_array&& ta) &
  {
    m_tableArrays.insert_or_assign(std::string(name), ta);
  }

  // TODO:
  // std::string serialize() const;

private:
  scl_file() = default;

  std::map<std::string, table, std::less<>> m_tables;
  std::map<std::string, table_array, std::less<>> m_tableArrays;
};

template<typename T>
struct member_pointer_destructure;

template<typename CLASS, typename X>
struct member_pointer_destructure<X CLASS::*>
{
  using class_type = CLASS;
  using value_type = X;
};

template<typename CLASS, typename X>
struct member_pointer_destructure<X CLASS::* const>
{
  using class_type = CLASS;
  using value_type = X;
};

template<typename T, typename OF>
concept is_member_pointer_of = requires(T t) {
  requires std::same_as<typename member_pointer_destructure<T>::class_type, OF>;
};

template<typename... Ts>
struct field_descriptor
{
  using fields = std::tuple<Ts...>;
};

template<auto N>
struct field_name_literal
{
  constexpr field_name_literal(char const (&str)[N])
  {
    std::copy(str, str + N, m_str);
  }

  constexpr operator std::string_view() { return m_str; }
  char m_str[N]{};
};

template<field_name_literal a>
constexpr auto
operator"" _f()
{
  return a;
};

template<auto const FIELD_PTR, field_name_literal const NAME>
struct field
{
  constexpr static auto ptr = FIELD_PTR;
  constexpr static std::string_view name = NAME.m_str;
};

template<typename T>
concept has_scl_fields_descriptor = requires { typename T::scl_fields; };

template<has_scl_fields_descriptor T>
static void
deserialize(T& into, auto table)
{
  using field_descriptor = T::scl_fields;
  using fields = field_descriptor::fields;

  std::apply(
    [&](auto... FIELDS) {
      (
        [&]<typename FIELD>(FIELD) {
          auto constexpr field_ptr = FIELD::ptr;
          using field_type =
            member_pointer_destructure<decltype(field_ptr)>::value_type;
          auto constexpr field_name = FIELD::name;

          auto&& val = table.find(field_name);
          if (val == table.end())
            throw std::runtime_error(
              std::format("unable to find value by name of {}", field_name));

          into.*field_ptr = val->second.template get<field_type>(std::format(
            "failed to get table value by name of {}, wrong type", field_name));
        }(FIELDS),
        ...);
    },
    fields());
}

};
