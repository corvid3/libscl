#pragma once

/* generated by c++gen */

#include <concepts>
#include <exception>
#include <format>
#include <iterator>
#include <list>
#include <map>
#include <string>
#include <string_view>
#include <type_traits>
#include <variant>
#include <vector>

namespace scl {

class value;

using string = std::string;
using number = double;
using array = std::vector<value>;

using table = std::map<std::string, value, std::less<>>;
using table_array = std::list<table>;

struct typename_visitor
{
  std::string_view operator()(string const&) { return "string"; }
  std::string_view operator()(number const&) { return "number"; }
  std::string_view operator()(array const&) { return "array"; }
};

class value
{
public:
  // TODO: uhhh get rid of this
  constexpr value() = default;

  constexpr value(std::string_view const& str)
    : m_value(std::string(str)) {};
  constexpr value(std::convertible_to<double> auto const num)
    : m_value(num) {};
  constexpr value(array&& a)
    : m_value(a) {};

  value(value const& rhs)
    : m_value(rhs.m_value) {};

  value& operator=(value const& rhs)
  {
    m_value = rhs.m_value;
    return *this;
  }

  template<typename T, typename EXCEPTION_TYPE = std::runtime_error>
  auto const& get(auto const... to_throw) const
  {
    if (std::holds_alternative<T>(m_value))
      return std::get<T>(m_value);
    else
      throw EXCEPTION_TYPE(to_throw...);
  }

  template<typename T, typename EXCEPTION_TYPE = std::runtime_error>
  auto& get(auto const... to_throw)
  {
    if (std::holds_alternative<T>(m_value))
      return std::get<T>(m_value);
    else
      throw EXCEPTION_TYPE(to_throw...);
  }

  void emplace(auto&& in) { m_value = in; }

  std::string_view get_internal_type_name() const
  {

    return std::visit(typename_visitor(), m_value);
  }

private:
  std::variant<string, number, array> m_value;
};

class scl_search_exception : public std::exception
{
public:
  scl_search_exception(std::string_view name)
    : name(name)
  {
    m_what = std::format("searching for {}, couldn't find it", name);
  }

  // what name one is looking for
  std::string_view const name;

  char const* what() const noexcept override { return m_what.c_str(); }

private:
  std::string m_what;
};

class scl_file
{
public:
  friend struct State;

  scl_file() = default;

  // parses a scl_file
  scl_file(std::string_view);

  bool table_exists(std::string_view name) const
  {
    return not(m_tables.find(name) == m_tables.end());
  }

  bool array_table_exists(std::string_view name) const
  {
    return not(m_tableArrays.find(name) == m_tableArrays.end());
  }

  auto& get_table(std::string_view name)
  {
    auto out = m_tables.find(name);
    if (out == m_tables.end())
      throw scl_search_exception(name);
    return out->second;
  }

  auto& get_table_array(std::string_view name)
  {
    auto out = m_tableArrays.find(name);
    if (out == m_tableArrays.end())
      throw scl_search_exception(name);
    return out->second;
  }

  auto const& get_table(std::string_view name) const
  {
    auto out = m_tables.find(name);
    if (out == m_tables.end())
      throw scl_search_exception(name);
    return out->second;
  }

  auto const& get_table_array(std::string_view name) const
  {
    auto out = m_tableArrays.find(name);
    if (out == m_tableArrays.end())
      throw scl_search_exception(name);
    return out->second;
  }

  auto num_tables() const { return m_tables.size(); }

  void insert_table(std::string_view name, table&& t) &
  {
    m_tables.insert_or_assign(std::string(name), t);
  }

  void insert_table_array(std::string_view name, table_array&& ta) &
  {
    m_tableArrays.insert_or_assign(std::string(name), ta);
  }

  // TODO:
  // std::string serialize() const;

private:
  std::map<std::string, table, std::less<>> m_tables;
  std::map<std::string, table_array, std::less<>> m_tableArrays;
};

template<typename T>
struct member_pointer_destructure;

template<typename CLASS, typename X>
struct member_pointer_destructure<X CLASS::*>
{
  using class_type = CLASS;
  using value_type = X;
};

template<typename CLASS, typename X>
struct member_pointer_destructure<X CLASS::* const>
{
  using class_type = CLASS;
  using value_type = X;
};

template<typename T, typename OF>
concept is_member_pointer_of = requires(T t) {
  requires std::same_as<typename member_pointer_destructure<T>::class_type, OF>;
};

template<typename... Ts>
struct field_descriptor
{
  using fields = std::tuple<Ts...>;
};

template<auto N>
struct field_name_literal
{
  constexpr field_name_literal(char const (&str)[N])
  {
    std::copy(str, str + N, m_str);
  }

  constexpr operator std::string_view() { return m_str; }
  char m_str[N]{};
};

template<field_name_literal a>
constexpr auto
operator"" _f()
{
  return a;
};

template<auto const FIELD_PTR,
         field_name_literal const NAME,
         auto const DEFAULT_VALUE = std::nullopt>
struct field
{
  constexpr static auto ptr = FIELD_PTR;
  constexpr static std::string_view name = NAME.m_str;
  constexpr static std::optional<
    typename member_pointer_destructure<decltype(FIELD_PTR)>::value_type>
    default_value = DEFAULT_VALUE;
};

template<typename T>
concept has_scl_fields_descriptor = requires { typename T::scl_fields; };

// thrown when a table by a name doesn't exist
class deserialize_table_error final : public std::runtime_error
{
public:
  deserialize_table_error(std::string_view table_name)
    : std::runtime_error(
        std::format("expected a table of name <{}> when deserializing",
                    m_tableName))
    , m_tableName(table_name) {};

  std::string m_tableName;
};

// thrown when a field is not found and there is no
// default value for the field
class deserialize_field_error final : public std::runtime_error
{
public:
  deserialize_field_error(std::string_view name, std::string_view table_name)
    : std::runtime_error(std::format(
        "expected a nonexisteent field by name of <{}> in table <{}>",
        name,
        table_name))
    , m_fieldName(name)
    , m_tableName(table_name) {};

  std::string m_fieldName, m_tableName;
};

// thrown when a field is found in a table,
// but the field is the wrong type
class deserialize_field_type_error final : public std::runtime_error
{
public:
  deserialize_field_type_error(std::string_view name,
                               std::string_view table_name,
                               std::string_view expected_type_name,
                               std::string_view found_type_name)
    : std::runtime_error(
        std::format("failed to get table value by name of <{}>, expected "
                    "<{}> but found <{}>"
                    ", in table {}",
                    name,
                    expected_type_name,
                    found_type_name,
                    table_name))
    , m_fieldName(name)
    , m_tableName(table_name)
    , m_expectedTypename(expected_type_name)
    , m_foundTypename(found_type_name) {};

  std::string m_fieldName, m_tableName, m_expectedTypename, m_foundTypename;
};

// DO NOT CALL THIS
template<typename fields>
void
internal_deserialize_field_unwrapper(auto& into,
                                     auto& table,
                                     auto const& table_name)
{
  std::apply(
    [&](auto const... FIELDS) {
      (
        [&]<typename FIELD>(FIELD) {
          auto constexpr field_ptr = FIELD::ptr;
          using field_type =
            member_pointer_destructure<decltype(field_ptr)>::value_type;
          auto constexpr field_name = FIELD::name;
          auto constexpr& field_default_value = FIELD::default_value;

          auto&& val = table.find(field_name);

          if (val == table.end()) {
            if (not field_default_value.has_value())
              throw deserialize_field_error(field_name, table_name);

            // hey we have a default value
            into.*field_ptr = *field_default_value;
          } else {
            // TODO: give better type error reporting by giving the name of
            // the type
            into.*field_ptr =
              val->second
                .template get<field_type, deserialize_field_type_error>(
                  field_name,
                  table_name,
                  typename_visitor()(field_type()),
                  val->second.get_internal_type_name());
          }
        }(FIELDS),
        ...);
    },
    fields());
};

// handles array tables
// must come first so the overload gets picked correctly
template<typename T, bool err_on_no_table = true>
  requires has_scl_fields_descriptor<typename T::value_type>
static bool
deserialize(std::insert_iterator<T> into_iter,
            scl_file const& file,
            std::string_view table_name)
{
  using deser_type = T::value_type;
  using field_descriptor = deser_type::scl_fields;
  using fields = field_descriptor::fields;

  if (not file.array_table_exists(table_name)) {
    if (not err_on_no_table)
      return false;
    else
      throw deserialize_table_error(table_name);
  }

  auto const& array_table = file.get_table_array(table_name);

  for (auto const& table : array_table) {
    deser_type into;
    internal_deserialize_field_unwrapper<fields>(into, table, table_name);
    into_iter = std::move(into);
  }

  return true;
}

// returns false if table doesn't exist
template<has_scl_fields_descriptor T, bool err_on_no_table = true>
static bool
deserialize(T& into, scl_file const& file, std::string_view table_name)
{
  using field_descriptor = T::scl_fields;
  using fields = field_descriptor::fields;

  if (not file.table_exists(table_name)) {
    if (not err_on_no_table)
      return false;
    else
      throw deserialize_table_error(table_name);
  }

  auto const& table = file.get_table(table_name);

  internal_deserialize_field_unwrapper<fields>(into, table, table_name);

  return true;
}

template<has_scl_fields_descriptor T>
static void
serialize(std::convertible_to<std::span<T const>> auto from,
          scl_file& file,
          std::string_view table_name)
{
  using field_descriptor = T::scl_fields;
  using fields = field_descriptor::fields;

  table_array array;

  for (auto const& val : from) {
    table table_;

    std::apply(
      [&](auto const... FIELDS) {
        (
          [&]<typename FIELD>(FIELD) {
            auto constexpr field_ptr = FIELD::ptr;
            auto constexpr field_name = FIELD::name;

            table_.insert_or_assign(std::string(field_name),
                                    value(val.*field_ptr));
          }(FIELDS),
          ...);
      },
      fields());

    array.push_back(std::move(table_));
  }

  file.insert_table_array(table_name, std::move(array));
};

// replaces table if it already exists in the file
template<has_scl_fields_descriptor T>
static void
serialize(T& from, scl_file& file, std::string_view table_name)
{
  using field_descriptor = T::scl_fields;
  using fields = field_descriptor::fields;

  table table_;

  std::apply(
    [&](auto const... FIELDS) {
      (
        [&]<typename FIELD>(FIELD) {
          auto constexpr field_ptr = FIELD::ptr;
          auto constexpr field_name = FIELD::name;

          table_.insert_or_assign(std::string(field_name),
                                  value(from.*field_ptr));
        }(FIELDS),
        ...);
    },
    fields());

  file.insert_table(table_name, std::move(table_));
};

};
